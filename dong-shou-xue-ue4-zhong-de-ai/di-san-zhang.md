# 第三章

## 导航

寻路的问题和克诺索斯的迷宫一样古老:我如何用最短的路线从A点到达B点，并避免中间的所有障碍?

许多算法已经被开发来解决寻路问题，包括那些与A\*算法相关的算法，该算法在20世纪60年代首次被引入计算机科学\(第2节\)。

寻路程序是许多游戏的典型组成，npc的任务是在游戏地图上找到最优路径，而这条路径是不断变化的。例如，通道、大门或门可以在游戏过程中改变它们的状态。

当涉及到寻路时，会有很多问题，而且对我们来说不幸的是，没有一种能够解决所有问题的方法。这是因为根据问题的类型，每个问题都有自己的解决方案。不仅如此，它还取决于你所开发的游戏类型。例如，AI角色的最终目的地是静态的建筑\(静止的\)，还是需要跳到漂浮的筏子上\(动态的\)?你还需要考虑地形——它是平坦的还是崎岖的?为了增加复杂性，我们还需要考虑是否存在障碍物，以及这些物体是否是静态的\(消防栓\)或是否可以移动\(例如盒子\)。然后，我们需要考虑实际的路径本身。例如，沿着公路跑可能更容易，但是在屋顶上跑会让你跑得更快。按照同样的思路，人工智能甚至可能没有最终目的地，也就是说，它们不必在某个特定的地方。例如，他们可能只是作为一个村庄的一部分四处游荡。然而，我只强调了几个与寻路相关的问题和注意事项。在使用寻路的不同情况下，您可能会遇到其他问题。记住要有耐心，考虑我在这里提到的所有变量，以及其他与你的情况相关的变量。对我们来说幸运的是，Unreal已经包含了一个可以能够在大多数情况下使用的导航系统。因此，我们不需要从头开始重新实现所有东西。本章的主要目标是确保您了解如何使用它，并确保您对如何扩展它有一些概念。

在本章中，我们将涵盖以下主题:

* 对**导航系统**有什么期待呢
* **虚幻的导航系统**是如何工作的
* 如何在关卡中**生成导航盒**并应用它
* 使用以下方法**修改导航盒**：
  * **Navigation Areas**，修改导航盒的部分权重
  * **Navigation Links**，连接两个部分的导航盒
  * **Navigation Filters**，在导航系统上执行特定查询时对导航网格执行轻微更改

让我们开始吧！

### 对**导航系统**有什么期待呢

首先，在我们探索虚幻导航系统之前，定义一下我们对通用导航系统的期望是很有用的。导航系统需要具备以下条件:

* 它需要确定地图上的两个通用点之间是否存在一个路径\(执行查询的代理可以遍历该路径\)
* 如果存在这样的路径，则返回对代理最方便的路径\(通常是最短的\)

然而，在寻找最佳路径的过程中，有很多方面需要考虑。一个好的导航系统不仅要考虑这些问题，还要在相对较短的时间内执行查询。其中一些方面如下:

* 执行查询的AI代理能够通过地图的特定部分吗?例如，可能有一个湖，而AI角色可能会也可能不会游泳。同样地，代理是否可以蹲下并进入通风隧道？
* AI代理可能想要避免\(或偏好\)某些路径，这些路径不一定是最短的。例如，如果一栋建筑着火了，代理应该尽量避免这种情况，否则就会有被烧毁的危险。再举个例子，假设有两条路:一条是被敌人火力覆盖的，但是很长;另一条是短的，但是暴露在敌人火力之下;应该选择哪一个呢?尽管这可能是决策过程的一部分，一些启发式算法可以在寻路的层次上实现，并且导航系统应该支持它们。
* 地图可能是动态的，这意味着在游戏过程中障碍、物体、道路、悬崖等等都会发生变化。导航系统能够实时处理这些变化，并纠正生成的路径吗?

现在，我们来看看Unreal是如何实现所有这些功能的。

### 虚幻的导航系统

虚幻导航系统是基于一个导航网格\(简称Nav网格\)。它需要将可导航空间划分为若干区域——在本例中为多边形——为了提高效率，它们被细分为三角形。然后，为了到达某个位置，将每个三角形视为图的一个节点，如果两个三角形相邻，则将它们各自的节点连接起来。在这个图中，你可以执行寻路算法，比如使用欧几里得距离启发式的A _，或者甚至是更复杂的东西\(例如A_ 的变体或考虑不同成本的系统\)。这将在这些三角形之间产生一条路径，AI角色可以在其中行走。

为了能够使用导航系统，让我们了解设置导航系统的主要过程。在这个阶段，我们将不再关心系统底层的结构，而是关心如何使用它的所有特性。系统将完成其余的工作。同样，我们需要向导航系统提供有关地图的信息\(例如指定特定区域\)。通常情况下，你的团队中的AI程序员会处理这个任务，但如果你的团队很小，关卡设计师可能会处理这个任务。虽然没有一个具体的过程，倒不如说是一个迭代的过程，让我们探索不同的步骤-或工具，如果你喜欢-你可以在虚幻引擎中定义Nav网格。我们将在本章中详细研究它们:

* **Generation of the Navigation Mesh**：这是第一步。在你使用以下工具之前，重要的是生成一个Nav网格。这个步骤包括定义如何生成多边形、三角形、导航网格的精度，甚至是哪种代理将穿过这个特定的导航网格。
* **Navigation Mesh Modifiers**：并不是所有的Nav网格部分都是相等的，这是一个工具，用于指定Nav网格的哪些部分的行为应该不同。事实上，正如我们以前看到的，可能存在一个带有有毒气体的区域，代理希望避免这个部分，除非他们真的必须穿过它。Nav网格修改器允许你指定包含气体的区域是特殊的。但是，区域内的行为类型\(例如，此路径不应该被遍历，或者只能由具有游泳能力的代理遍历\)是在导航区域内指定的。
* **Navigation Areas**：这允许您指定特定类型的区域的行为方式，是否应该避免，等等。重要的是在执行Nav过滤以确定代理可以遍历哪些区域时。
* **Navigation Links**：这些可以连接两个不同的部分的Nav网格。假设你有一个平台。默认情况下，AI代理会找到另一种方法。如果你想到的是第三人称地图模板，那么需要从平台上下来的代理将会绕着这个区域走楼梯，而不是从平台上掉下来或跳下。导航链接允许你连接平台顶部和下方的部分导航网格。因此，AI角色可能会从平台上掉下来。然而，请注意Nav链接可以连接Nav的两个通用部分网格，从而允许寻路通过跳跃，传送等找到它的路。
* **Nav Filtering**：我们不一定要在任何场合都以同样的方式找到一条路。Nav过滤允许我们定义如何执行特定实例的路径查找的特定规则\(在特定时间调用路径查找来寻找路径\)。

让我们把这些要点分解并更详细地讨论一下：

### 生成导航网格

在Unreal中生成一个简单的导航网格非常简单。我们来看看怎么做。在Mode面板中，在Volume选项卡中，你可以找到Nav Mesh Bounds Volume，如下截图所示:进入翻译页面

![](../.gitbook/assets/3.1.jpg)

把它拖到世界上。您将注意到，相对于地图而言，体积是相当小的。在这个体积内的一切将被考虑到生成一个Nav网格。当然，一个导航网格有很多参数，但现在让我们保持默认。

如果你按下键盘上的P按钮，你就可以在视窗中看到Nav网格，如下图所示:

![](../.gitbook/assets/3.2.jpg)

正如你所看到的，它被限制在Nav Mesh Bounds Volume范围内。让我们缩放Nav Mesh Bounds Volume，以适应我们的关卡。你的关卡应该是这样的:

![](../.gitbook/assets/3.3.jpg)

你有没有注意到，当你缩放你的volume,时，导航网格是如何自动更新的?这是因为，在虚幻中每次有影响导航网格的东西移动时，都会生成导航网格。更新时，受影响的部分\(即更新后的部分\)将变成红色，如下图所示:

![](../.gitbook/assets/3.4.jpg)

这就是如何容易生成一个导航网格。然而，为了能够掌握这个工具，我们需要学习更多关于如何细化Nav网格和它是如何被AI使用的。

### 设置导航网格的参数

如果你点击Nav Mesh Bounds Volume，你会发现没有生成Nav网格的选项。实际上，一些参数位于项目级别，而其他参数位于地图级别。

让我们选择到World Outliner，在那里你会发现场景中已经放置了默认的RecastNavMesh- Default actor，如下截图所示:

![](../.gitbook/assets/3.5.jpg)

事实上，当你拖动Nav Mesh Bounds Volume，如果地图没有RecastNavMesh-Default，将自动创建一个。如果我们点击它，我们可以在细节面板中更改它的所有属性。

可以看到，有很多默认值。这些可以在项目设置\(在导航网格选项卡下\)。让我们拆分每个部分，并尝试掌握围绕它们的主要概念。

#### 显示设置

顾名思义，这些设置与我们如何可视化详细生成的导航网格有关。特别是，我们将能够看到生成的多边形，三角形，以及多边形是如何连接的。我们将在第12章中更详细地讨论这些问题，当我们谈到调试工具时:

![](../.gitbook/assets/3.6.jpg)

#### 生成设置

这些设置关系到Nav网格的生成。通常，一开始使用默认值是非常完美的，因此只有在知道自己在做什么时才应该接触这些值。下面的截图显示了这些设置:

![](../.gitbook/assets/3.7.jpg)

了解这些设置的最佳方法是使用它们的参数，开始前，让我们看看主要的几点:

* **Tile Size UU**：这个参数定义了生成的多边形的精细程度。更低的值意味着更精确的导航网格，有更多的多边形，但也会更慢的生成时间\(以及可能更多的内存使用\)。通过在显示设置中启用“绘制三角形边”，可以看到此参数的效果。
* **Cell Height**：这决定了产生的网格离地板有多高\(这可能导致不同的高度连接，所以要小心\)。
* Agent settings \(**Radius**, **Height**, **Max Height**, **Max Slope**, **Max Step Height**\):这些设置是特定于您的代理的，应该适当地指定。特别地，这些是一个代理应该穿过这个Nav网格的最小值。因此，导航网格将无法与小于此值的代理导航，因为导航网格仅为具有这些要求的代理生成。这些设置对于为你的代理生成一个合适的导航网非常有用，而不会浪费资源在你的代理永远无法导航的区域上。
* **Min Region Area**：这样可以消除Nav网格生成中的某些不重要而无法导航的工件。

剩下的许多设置都是关于优化的，它们可能是难以理解的，特别是对于人工智能编程新手。因此，我决定在本书中不包括这些细节。但是，一旦您对使用导航系统有了信心，您可以查看这些设置的工具提示，并对它们进行试验，以便了解它们的作用。

#### 项目设置

值得一提的是，即使我们不详细介绍它们，也可以从项目设置中更改相同的导航设置；有一个特定的选项卡，如下图所示：

![](../.gitbook/assets/3.8.jpg)

有趣的是关于代理的最后一个选项卡。在这里可以创建一个支持的代理的数组，这样不同的代理可以有不同的方式浏览Nav网格。例如，一只老鼠可能和Giant Troll有一个不同的导航网格。事实上，老鼠也可以进入小洞，而Giant Troll不能。在这里，您将能够指定所有不同类型的代理:

![](../.gitbook/assets/3.9.jpg)

你不能直接指定你的角色将遵循哪种类型的代理，但是，基于 Character Movement组件\(或一般的Movement组件\)，一种代理会被分配给 Character/AI代理。

**在Character Movement组件中设置**

正如我们在上一节中所看到的代理的能力，它的形状等等……对导航网格的导航方式有很大影响。您将能够在Character Movement组件上找到这些设置。

但是，这个组件超出了本书的范围，我们将不会看到它。

### 修改导航网格

到目前为止，我们已经了解了如何生成一个导航网格。但是，我们想修改一下，使它更适合我们的需要。正如我们之前提到的，可能会有不同的区域需要花费很大的代价才能穿过，或者可能会有一个在导航网的两个点之间的连接，而它们是分开的。

因此，本节探讨了Unreal中修改导航网格的不同工具，使它可以适应地图。

#### Nav Modifier Volume

好了-是时候看看我们如何开始修改Nav网格了。例如，可能有一部分Nav网格我们不想交叉，或另一部分我们想有不同的属性。我们可以通过使用Nav Modifier Volume来做到这一点。

你可以通过进入Model面板，在Volume选项卡下找到这个设置，然后进入Nav Mesh Bounds Volume:

![](../.gitbook/assets/3.10.jpg)

一旦这个体积被放置到地图中，默认值是移除体积内的Nav网格部分，如下面的截图所示:

![](../.gitbook/assets/3.11.jpg)

当你有不希望AI进入的区域，或者修复导航网格的工件时，这是很有用的。虽然Nav Modifier Volume指定了地图的一部分，行为是指定在Nav Modifier Areas。这意味着，如果我们查看Nav Mesh Modifier Volume的设置，我们只能找到一个与导航相关的，名为Area类:

![](../.gitbook/assets/3.12.jpg)

因此，此volume只能指定地图的一部分，其中特定的是Area类。默认情况下，Area类是NavArea\_Null，“移除”地图中重叠这个体积的部分的Nav网格。下一节我们将探讨Nav网格区域是如何工作的。

#### Nav Mesh Areas

在上一节中，我们讨论了地图的可导航区域并非都是一样的。如果有一个区域被认为是危险的，人工智能应该避免它。虚幻的内置导航系统能够使用costs处理这些不同的领域。这意味着人工智能将通过对路径上所有代价求和来评估路径，然后选择代价最小的路径。

另外，值得指出的是有两种类型的costs。对于每个区域，都有进入\(或离开\)该区域的初始costs和穿过该区域的costs。让我们看几个例子来说明两者之间的区别。

假设有一片森林，但是在森林的每一个入口，人工智能都需要向居住在森林中的土著居民支付费用。然而，一旦进入，人工智能可以自由移动，就像他们在森林之外。在本例中，进入森林是有代价的，但是一旦进入森林，就没有代价了。因此，当人工智能需要评估是否要穿越森林时，它取决于是否有另一条路要走以及需要多长时间。

现在，假设有一个地区有毒气。在第二个场景中，进入该区域的代价可能为零，但是穿过该区域的代价很高。事实上，人工智能在该地区停留的时间越长，它失去的健康值就越多。它是否值得进入不仅取决于是否有另一种路径以及该替代路径需要多长时间才能穿过\(就像前面的例子一样\)，还取决于一旦进入，AI需要多长时间才能穿过该区域。

在虚幻中，costs是在类内指定的。如果你点击一个Nav Modifier Volume，你会注意到你需要指定一个Area类，如下面的截图所示:

![](../.gitbook/assets/3.13.jpg)

您可能已经猜到，默认值是NavArea\_Null，它的进入cost是无限的，导致AI永远不会进入该区域。导航系统非常聪明，甚至不需要生成该区域，而是将其视为不可导航区域。

但是，您可以更改Area类。默认情况下，您将能够访问以下Area类:

* **NavArea\_Default**；这是生成的默认区域。如果您想在同一位置有多个这样的修饰符，那么将它作为一个修饰符是很有用的。
* **NavArea\_LowHeight**：这表明，由于高度降低，该区域并不适合每一种代理\(例如，在通风隧道的情况下，不是所有的代理都适合/蹲下\)。
* **NavArea\_Null**：这使得该区域对所有代理都不可导航。
* **NavArea\_Obstacle**：这将为该地区分配更高的成本，因此代理将希望避免它。

![](../.gitbook/assets/3.14.jpg)

但是，您可以通过扩展NavArea类来扩展不同Areas的列表\(并可能添加更多的功能\)。让我们看看如何在Blueprint和C++中做到这一点。当然，正如我们在前一章所做的，我们是将创建一个名为Chapter3/Navigation的新文件夹，我们将在其中放置所有代码。

**在蓝图中创建NavArea**

在蓝图中创建一个新的NavArea类非常简单;你只需要创建一个从NavArea类继承的新蓝图，如下面的截图所示:

![](../.gitbook/assets/3.15.jpg)

按照惯例，类的名称应该以“NavArea\_”开头。我们将在这里重命名为NavArea\_BPJungle\(我添加了BP来表示我们已经创建的这是关于蓝图的，因为我们在蓝图和C++中都在重复同样的任务\)。这是它在Content Browser中的样子:

![](../.gitbook/assets/3.16.jpg)

然后，如果您打开蓝图，您将能够分配自定义costs的Area。你也可以为你的区域指定一个特定的颜色，这样当你构建Nav网格时就很容易识别。这是细节面板默认的样子:

![](../.gitbook/assets/3.17.jpg)

现在，我们可以根据我们的需要进行定制。例如，我们可能想要进入丛林的成本，以及穿越丛林的略高的成本。我们将使用明亮的绿色作为颜色，如下面的截图所示:

![](../.gitbook/assets/3.18.jpg)

一旦编译并保存，我们就可以将这个新创建的Area分配给Nav Modifier Volume，如下图所示:

![](../.gitbook/assets/3.19.jpg)

这是我们完成的类在我们的关卡中看起来的样子\(如果导航网格是可见的\):

![](../.gitbook/assets/3.20.jpg)

**在C++中创建NavArea**

在C++中创建NavArea类也很容易。首先，您需要创建一个新的C++类，它继承自NavArea类，如下面的截图所示:

![](../.gitbook/assets/3.21.jpg)

按照惯例，名字应该以“NavArea\_”开头。因此，你可以将它重命名NavArea\_Desert\(只是为了改变AI可以面对的地形类型，因为我们之前创建了一个丛林\)，并将它放到“Chapter3/Navigation”中:

![](../.gitbook/assets/3.22.jpg)

创建了类之后，只需在构造函数中分配参数。为了方便起见，下面是类定义，我们在其中声明了一个简单的构造函数:

```cpp
#include "CoreMinimal.h"
#include "NavAreas/NavArea.h"
#include "NavArea_Desert.generated.h"

/**
 * 
 */
UCLASS()
class UNREALAIBOOK_API UNavArea_Desert : public UNavArea
{
  GENERATED_BODY()
  UNavArea_Desert();

};
```

然后，在构造函数的实现中，我们可以分配不同的参数。例如，我们可能会有较高的输入成本和较高的穿过成本\(相对于默认值或丛林\)。此外，我们可以将颜色设置为黄色，这样我们就能记住它是沙漠区域:

```cpp
#include "NavArea_Desert.h"
UNavArea_Desert::UNavArea_Desert()
{
  DefaultCost = 1.5f;
  FixedAreaEnteringCost = 3.f;
  DrawColor = FColor::Yellow;
}
```

一旦你创建了类，你可以把它设置为Nav Modifier Volume的一部分，如下图所示:

![](../.gitbook/assets/3.23.jpg)

因此，你将能够在Nav网格看到你的自定义区域\(在这种情况下，是黄色\):

![](../.gitbook/assets/3.24.jpg)

#### Nav Link Proxy

默认情况下，如果有一个ledge，人工智能不会掉下去，即使这是他们能走到目的地的最短路径。事实上，在顶部的导航网窗台不是\(直接\)连接到底部的导航网。 然而，虚幻导航系统提供了一种方法，通过所谓的Nav Link Proxy连接导航网格中的任意两个三角形。

让我们更详细地研究这个工具。

**创建Nav Link Proxy**

要用一个链接连接两个区域，我们需要在Mode面板All Classes选项卡，选择Nav Link Proxy，如下图所示:

![](../.gitbook/assets/3.25.jpg)

